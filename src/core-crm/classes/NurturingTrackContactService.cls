/**
 * @description helper class for NurturingTrackContactService 
 * @see NurturingTrackContactBatch
 *
 * @author Accenture-
 *
 * @history
 *
 *    | Developer Email                | Date                  | JIRA                   | Change Summary                                                                |
      |--------------------------------|-----------------------|------------------------|-------------------------------------------------------------------------------|
      | mark.j.mahilum                 | July 25, 2023         | DEPP-6105              | Created file                                                                  |
      | eccarius.munoz                 | August 08, 2023       | DEPP-5760              | Added handling for Domestic and International                                 |  
      |                                |                       |                        | Enrolment to Census                                                           | 
      | mark.j.mahilum                 | Sept 07, 2023         | DEPP-6479              | Updated methods to replace the Term Intake to                                 |
      |                                |                       |                        | Calculated Intake Date on application record                                  | 
      | mark.j.mahilum                 | Sept 08, 2023         | DEPP-6479              | Remove CURRENT_INTAKE_PERIOD and NurturingTrackService.isDateWithinRange call |
      |                                |                       |                        | as it's no longer used                                                        |
      | arsenio.jr.dayrit              | September 07, 2023    | DEPP-5652              | Added handling for Domestic Strong Interest Pre-Application                   |
      | mark.j.mahilum                 | Sept 19, 2023         | DEPP-6677              | Updated name of sales cadence from Domestic Acceptance to Enrollment to       |
      |                                |                       |                        | Domestic Accepted not yet Enrolled                                            |
      | arsenio.jr.dayrit              | October 03, 2023      | DEPP-6816              | Added handling for International Offer to Acceptance                          |
      | alexander.cadalin              | Oct 3, 2023           | DEPP-6814              | Fixed case detection logic for international strong interest                  |
      | mark.j.mahilum                 | October 04, 2023      | DEPP-6682              | Added new entry criteria for DomesticAcceptedAdmitted sales cadence           |
      | arsenio.jr.dayrit              | October 04, 2023      | DEPP-6834              | Update handling for Domestic Accepted not yet Enrolled                        |
      | arsenio.jr.dayrit              | October 06, 2023      | DEPP-6853              | Update handling for Domestic Strong Interest Pre Application                  |
      | mark.j.mahilum                 | Oct. 06, 2023         | DEPP-6854              | Updated handing for Domestic International Start Date                         |
      | arsenio.jr.dayrit              | Oct. 12, 2023         | DEPP-6901              | Added international citizenship status handling                               |
      | eccarius.munoz                 | October 16, 2023      | DEPP-6914              | Updated handling for Domestic First Offer (Auto). Changed checking of field   | 
      |                                |                       |                        | Admission process. Should be either RTN_DEFER or RTN_QTAC.                    | 
      | eccarius.munoz                 | October 16, 2023      | DEPP-6914              | Transffered String literals (Domestic First Offer Auto && Census)             | 
      |                                |                       |                        | to NurtureTrackConfigurationsDAO.                                             |
      | arsenio.jr.dayrit              | Oct. 19, 2023         | DEPP-6958              | Added Domestic Deffered Offer to Acceptance exit handling                     |
      | arsenio.jr.dayrit              | Nov. 20, 2023         | DEPP-7268              | Added Domestic First Offer to Acceptance entry and exit criteria              |
      | roy.nino.s.regala              | Jan. 03, 2023         | Shutdown PMD Fix       | Fix cyclomatic complexity issues                                              |

 */
public with sharing class NurturingTrackContactService { //NOPMD
    private static List<hed__Application__c> applicationList = new List<hed__Application__c>();
    private static List<hed__Application__c> applicationListForStrongInterest = new List<hed__Application__c>();
    private static Map<Id,hed__Application__c>  samsAppWithQtac = new Map<Id,hed__Application__c>();
    private static Map<String,String> appToQtacMap = new Map<String,String>();
    private static Map<String,Nurture_Track_Configuration__c>  nurturingTrackWithOffSetDaysMap = new Map<String,Nurture_Track_Configuration__c>();
    private static Map<String,Nurture_Track_Configuration__c>  nurturingTrackForExitWithOffSetDaysMap = new Map<String,Nurture_Track_Configuration__c>();
    private static Map<String,Nurture_Track_Configuration__c>  nurturingTrackWithThresholdForEntry = new Map<String,Nurture_Track_Configuration__c>();
    private static Map<Id, Set<String>> applicantIdsWithCompletedCadence = new Map<Id, Set<String>>(); 
    private static Map<Id, Set<String>> applicantIdsWithAllCompletedCadence = new Map<Id, Set<String>>();
    private static List<Case> caseList;
    private static Map<Id, Contact> domesticEntryContactMap = new Map<Id, Contact>();
    private static Map<Id, Contact> domesticExitContactMap = new Map<Id, Contact>();
    private static Map<Id, Contact> internationalEntryContactMap = new Map<Id, Contact>();
    private static Map<Id, Contact> internationalExitContactMap = new Map<Id, Contact>();
    private static final String DOMESTIC_ACCEPTANCE_TO_ENROLLMENT = 'DomesticAcceptanceToEnrollment';
    private static final String INTERNATIONAL_DIRECT_APPLICANT = 'InternationalDirectApplicants';
    private static final String DOMESTIC_DEFFERED_OFFER_TO_ACCEPTANCE = 'DomesticDeferredOfferToAcceptance';
    private static final String DOMESTIC_OFFER_LAPSED_AUTOMATED = 'Domestic Offer Lapsed (Automated)';
    private static final String DOMESTIC_OFFER_LAPSED_MANUAL = 'Domestic Offer Lapsed';
    private static final Map<String, Date> CURRENT_INTAKE_PERIOD = NurturingTrackService.getCurrentIntakePeriod();
    private static final Set<String> ALL_CADENCES = new Set<String>{
        NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_MANUAL,
        NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_AUTOMATED,
        NurtureTrackConfigurationsDAO.INTERNATIONAL_ACCEPTANCE_DEPOSIT_NOT_PAID_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_AUTOMATED,
        NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_DEFERRED_OFFER_TO_ACCEPTANCE_MANUAL, 
        NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_AUTOMATED,
        NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE,
        NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_AUTOMATED,
        NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_MANUAL,
        NurtureTrackConfigurationsDAO.INTERNATIONAL_APPLICATION_TO_OFFER_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED,
        NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_AND_ADMITTED_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_OFFER_LAPSED_MANUAL,
        NurtureTrackConfigurationsDAO.DOMESTIC_OFFER_LAPSED_AUTOMATED,
        NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL,
        NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED
    };

    /**
     * @description: process All contacts for Entry and Exit in Cadences assignment
     *
     * @param Map<Id, Contact> contactMap - contacts to process
     * @return List<Contact> contacts to update
     */
    public static List<Contact> processContactForEntryAndExit(Map<Id, Contact> contactMap) {
        Map<Id, Contact> contactToUpdate = new Map<Id, Contact>();

        //query all the related records required for each entry/exit criteria
        getAllRelatedRecords(contactMap);

        //CALL YOUR ENTRY AND EXIT METHOD HERE PASS ONLY THE

        /**
         * Arrangement according to DEPP-6061
         *   International Application Submission - Direct Applicant (DEPP-6058)
         *   International Application to Offer (DEPP-5746)
         *   Domestic First Offer to Acceptance (DEPP-5747)
         *   Domestic Deferred Offer to Acceptance (DEPP-5755)
         *   International Offer to Acceptance (DEPP-5756)
         *   International Acceptance Deposit not Paid (DEPP-5757)
         *   Domestic Accepted not yet Enrolled (DEPP-5758)
         *   Domestic and International Enrolment to Census (DEPP-5760)
         *   Domestic Offer Lapsed (DEPP-5761)
         */

        //Contact entry criteria to process
        contactToUpdate.putall(getDomesticStrongInterestPreApplicationForEntry(domesticEntryContactMap));
        contactToUpdate.putAll(getEntryInternationalStrongInterestPreApplication(internationalEntryContactMap));
        contactToUpdate.putall(getEntryInternationalDirectApplicants(internationalEntryContactMap));
        contactToUpdate.putAll(getEntryInternationalApplicationToOffer(internationalEntryContactMap));
        contactToUpdate.putall(getEntryDomesticFirstOffertoAcceptance(domesticEntryContactMap));
        contactToUpdate.putAll(getDomesticDeferredOfferToAcceptanceForEntry(domesticEntryContactMap));
        contactToUpdate.putAll(getInternationalOfferToAcceptanceForEntry(internationalEntryContactMap));
        contactToUpdate.putall(getEntryInternationalAcceptanceDepositNotPaid(internationalEntryContactMap));
        contactToUpdate.putAll(getDomesticAcceptanceToEnrollmentForEntry(domesticEntryContactMap));
        contactToUpdate.putAll(getEntryDomesticAcceptedAndAdmitted(domesticEntryContactMap));
        contactToUpdate.putAll(getDomesticEnrollmentToCensusForEntry(domesticEntryContactMap));
        contactToUpdate.putAll(getInternationalEnrollmentToCensusForEntry(internationalEntryContactMap));
        contactToUpdate.putall(getEntryDomesticOfferLapsed(domesticEntryContactMap));

        //Contact exit criteria to process
        contactToUpdate.putAll(getDomesticStrongInterestPreApplicationForExit(domesticExitContactMap));
        contactToUpdate.putAll(getExitInternationalStrongInterestPreApplication(internationalExitContactMap));
        contactToUpdate.putAll(getExitInternationalDirectApplicants(internationalExitContactMap));
        contactToUpdate.putAll(getExitInternationalApplicationToOffer(internationalExitContactMap));
        contactToUpdate.putAll(getExitDomesticFirstOffertoAcceptance(domesticExitContactMap));
        contactToUpdate.putAll(getDomesticDeferredOfferToAcceptanceForExit(domesticExitContactMap));
        contactToUpdate.putAll(getExitInternationalOffertoAcceptance(internationalExitContactMap));
        contactToUpdate.putAll(getExitInternationalAcceptanceDepositNotPaid(internationalExitContactMap));
        contactToUpdate.putAll(getDomesticAcceptanceToEnrollmentForExit(domesticExitContactMap));
        contactToUpdate.putAll(getDomesticEnrollmentToCensusForExit(domesticExitContactMap));
        contactToUpdate.putAll(getInternationalEnrollmentToCensusForExit(internationalExitContactMap));
        contactToUpdate.putAll(getExitDomesticOfferLapsed(domesticExitContactMap));
        
        return contactToUpdate.values();
    }

    /**
     * @description: Query all the required records needed for each entry and exit criteria
     *
     * @param Map<Id,Contact> mapOfContacts record to query
     */
    private static void getAllRelatedRecords(Map<Id, Contact> mapOfContacts) {
        applicationListForStrongInterest.addAll(ApplicationsDAO.newInstance()
            .getApplicationsByContactIds(mapOfContacts.keySet(), 'SYSTEM_MODE'));
        getAppsWithLatestCalculatedIntakeDatePerContact(mapOfContacts.keySet());
        getContactRecordCitizenship(mapOfContacts);
        getFilteredNurturingTrackRecords();
        
        List<Completed_Cadence__c> completedCadenceList = CompletedCadencesDAO.newInstance().getCompletedCadenceByTargetIds(mapOfContacts.keySet(),ALL_CADENCES,'SYSTEM_MODE');
        //get all successful completed cadences related to the contact
        applicantIdsWithCompletedCadence = NurturingTrackService.getApplicantIdsWithCompletedCadence(
            mapOfContacts.keySet(),
            completedCadenceList,
            Contact.getSObjectType()
        );

        //get all completed cadences regardless of the status related to the contact
        applicantIdsWithAllCompletedCadence = NurturingTrackService.getApplicantIdsWithAllCompletedCadence(
            mapOfContacts.keySet(),
            completedCadenceList,
            Contact.getSObjectType()
        );

    }

    private static void getAppsWithLatestCalculatedIntakeDatePerContact(Set<Id> contactIds){
        
        Map<String, hed__Application__c> contactToOnePerApplicationRTMap = new Map<String, hed__Application__c>();
        for(hed__Application__c app : ApplicationsDAO.newInstance()
        .getAppsWithLatestCalculatedIntakeDateByApplicantIds(contactIds, 'SYSTEM_MODE')){
            //gets the contact id + app recordtype string combo
            //make this string combo the key
            //this ensures that application list will only have 1 per contact and app record type
            String contactToAppRTCombo = (String)app.hed__Applicant__c + (String)app.RecordTypeId;
            if(!contactToOnePerApplicationRTMap.containsKey(contactToAppRTCombo)){
                contactToOnePerApplicationRTMap.put(contactToAppRTCombo,app);
            }
        }
        //add all application with unique contact and recordtype
        applicationList.addAll(contactToOnePerApplicationRTMap.values());
    }


    /**
     * @description: separate the contact for international or domestic
     *
     * @param Map<Id,Contact> mapOfContacts
     */
    private static void getContactRecordCitizenship(Map<Id, Contact> mapOfContacts) {
        for (Id key : mapOfContacts.KeySet()) {
            Contact con = mapOfContacts.get(key);
            Boolean isContactDomestic = (con.hed__Citizenship_Status__c == 'Domestic');
            Boolean isContactInternational = (con.hed__Citizenship_Status__c == 'International');

            if (String.isEmpty(con.Calculated_Cadence__c)) {
                if (isContactDomestic) {
                    domesticEntryContactMap.put(key, con);
                } else if(isContactInternational){
                    internationalEntryContactMap.put(key, con);
                }
            } else {
                if (isContactDomestic) {
                    domesticExitContactMap.put(key, con);
                } else if(isContactInternational){
                    internationalExitContactMap.put(key, con);
                }
            }
        }
    }

    /**
     * @description Update international direct applicant contacts based on entry criteria
     * @param Map<Id, Contact> internationEntryContactMap a map of ids to entry international contact records
     * @return Map<Id, Contact> map of id to updated contact records for batch processing
     */
    private static Map<Id, Contact> getEntryInternationalDirectApplicants(
        Map<Id, Contact> internationalEntryContactMap
    ) {
        Map<Id, hed__Application__c> internationalDirectApplicants = new Map<Id, hed__Application__c>();
        Set<String> newOrUnsubmittedStatus = new Set<String>{ 'New', 'Unsubmitted' };
        Set<String> completedCadencesCopy = new Set<String>();
        for (hed__Application__c application : applicationList) {
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            if (
                internationalEntryContactMap.containsKey(application.hed__Applicant__c) &&
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID &&
                newOrUnsubmittedStatus.contains(application.Application_Status__c) &&
                NurturingTrackService.isDateWithinRange(
                    application.Calculated_Intake_Date__c,
                    CURRENT_INTAKE_PERIOD.get('START_DATE'),
                    CURRENT_INTAKE_PERIOD.get('END_DATE')
                ) &&
                application.Is_Agent_Assisted__c == false && 
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.INTERNATIONAL_TRACK_SUCCEEDING_DIRECT_APPLICANT)
            ) {
                internationalDirectApplicants.put(application.Id, application);
            }
        }

        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{
                NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_MANUAL,
                NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_AUTOMATED
            },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_AUTOMATED,
            NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_MANUAL
        );

        List<Contact> contactToUpdateList = (List<Contact>) NurturingTrackService.populateCalculatedCadenceMultiple(
            filteredApplicantIdsWithCompletedCadence,
            internationalDirectApplicants.values(),
            cadenceWrapper
        );

        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>(contactToUpdateList);
        return contactToUpdateMap;
    }

    /**
     * @description Update international direct applicant contacts based on entry criteria
     * @param Map<Id, Contact> internationEntryContactMap a map of ids to entry international contact records
     * @return Map<Id, Contact> map of id to updated contact records for batch processing
     */
    private static Map<Id, Contact> getEntryInternationalAcceptanceDepositNotPaid(
        Map<Id, Contact> internationalEntryContactMap
    ) {
        Map<Id, hed__Application__c> internationalDirectApplicants = new Map<Id, hed__Application__c>();
        Set<String> completedCadencesCopy = new Set<String>();

        for (hed__Application__c application : applicationList) {
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            if (
                internationalEntryContactMap.containsKey(application.hed__Applicant__c) &&
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID &&
                application.Is_Agent_Assisted__c == false &&
                application.Application_Status__c == 'Acceptance - Pending Payment' &&
                NurturingTrackService.isDateWithinRange(
                    application.Calculated_Intake_Date__c,
                    CURRENT_INTAKE_PERIOD.get('START_DATE'),
                    CURRENT_INTAKE_PERIOD.get('END_DATE')
                ) && 
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.INTERNATIONAL_TRACK_SUCCEEDING_ACCEPTANCE_DEPOSIT_NOT_PAID)
            ) {
                internationalDirectApplicants.put(application.Id, application);
            }
        }

        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.INTERNATIONAL_ACCEPTANCE_DEPOSIT_NOT_PAID_MANUAL },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            '',
            NurtureTrackConfigurationsDAO.INTERNATIONAL_ACCEPTANCE_DEPOSIT_NOT_PAID_MANUAL
        );

        List<Contact> contactToUpdateList = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            internationalDirectApplicants.values(),
            cadenceWrapper
        );

        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>(contactToUpdateList);
        return contactToUpdateMap;
    }

    /**
     * @description: Check if the contact is for Entry Domestic Acceptance To Enrollment cadences
     *
     * @param Map<Id,Contact> mapOfContacts record to evaluate
     * @return Map<Id,Contact> of domestic acceptance contact
     */
    public static Map<Id, Contact> getDomesticAcceptanceToEnrollmentForEntry(
        Map<Id, Contact> domesticEntryContactMap
    ) {
        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>();
        Map<Id, hed__Application__c> domesticAcceptanceToEnrollmentAutomated = new Map<Id, hed__Application__c>();
        Map<Id, hed__Application__c> domesticAcceptanceToEnrollmentManual = new Map<Id, hed__Application__c>();
        Set<Id> existingContactIdOnApplication = getDomesticAcceptanceToEnrollmentEntryFilter(
            applicationList
        );
        Set<Id> existingContactIdOnAppWithProgram = getContactOnApplicationWithProgramPlan(
            applicationList,
            NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL
        );
        Set<String> completedCadencesCopy = new Set<String>();

        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_AUTOMATED },
            applicantIdsWithCompletedCadence
        );

        for (hed__Application__c application : applicationList) {
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            Boolean hasExistingApplication = existingContactIdOnApplication.contains(
                application.hed__Applicant__c
            );
            Boolean hasExistingCompletedCadence = filteredApplicantIdsWithCompletedCadence.containsKey(application.hed__Applicant__c);
            Boolean hasExistingApplicationWithProgram = existingContactIdOnAppWithProgram.contains(
                application.hed__Applicant__c
            );
            Boolean checkForManual = (hasExistingCompletedCadence && hasExistingCompletedCadence);

            //make sure that there are no completed cadence against any succeeding cadence
            //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
            if(completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.DOMESTIC_TRACK_SUCCEEDING_NOT_YET_ENROLLED)){
                continue;
            }

            boolean entryForManual = domesticEntryContactMap.containsKey(application.hed__Applicant__c) 
            && hasExistingApplication && hasExistingApplicationWithProgram 
            && hasExistingCompletedCadence;

            boolean entryForAutomated = domesticEntryContactMap.containsKey(application.hed__Applicant__c) && hasExistingApplication && !checkForManual;

            if (entryForManual) {
                domesticAcceptanceToEnrollmentManual.put(application.Id, application);
            } else if (entryForAutomated) {
                domesticAcceptanceToEnrollmentAutomated.put(application.Id, application);
            }
        }

        getCompletedCadenceForDomesticAcceptanceToEnrollmentAutomated(
            domesticEntryContactMap,
            domesticAcceptanceToEnrollmentAutomated,
            contactToUpdateMap
        );
        getCompletedCadenceForDomesticAcceptanceToEnrollmentManual(
            domesticEntryContactMap,
            domesticAcceptanceToEnrollmentManual,
            contactToUpdateMap
        );

        return contactToUpdateMap;
    }

    /**
     * @description: Check if the contact is for Entry of Domestic Deferred Offer to Acceptance cadences
     *
     * @param Map<Id,Contact> mapOfContacts record to evaluate
     * @return Map<Id,Contact> of domestic acceptance contact
     */
    public static Map<Id, Contact> getDomesticDeferredOfferToAcceptanceForEntry(
        Map<Id, Contact> domesticEntryContactMap
    ) {
        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>();
        Map<Id, hed__Application__c> domesticDeferredOfferToAcceptanceManual = new Map<Id, hed__Application__c>();
        Set<Id> existingContactIdOnApplication = new Set<Id>();
        Set<String> completedCadencesCopy = new Set<String>();

        if(!applicationList.isEmpty()){
            existingContactIdOnApplication.addAll(getContactOnApplicationForDomesticDeferredOfferToAcceptanceEntryFilter(
                applicationList,
                'DomesticDeferredOfferToAcceptance'
            ));
        }
    
        for (hed__Application__c application : applicationList) {
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            Boolean hasExistingApplication = existingContactIdOnApplication.contains(
                application.hed__Applicant__c
            );
            if (
                domesticEntryContactMap.containsKey(application.hed__Applicant__c) &&
                hasExistingApplication && 
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.DOMESTIC_TRACK_SUCCEEDING_DEFFERED_OFFER)
            ) {
                domesticDeferredOfferToAcceptanceManual.put(application.Id, application);
            }
        }

        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_DEFERRED_OFFER_TO_ACCEPTANCE_MANUAL },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            null,
            NurtureTrackConfigurationsDAO.DOMESTIC_DEFERRED_OFFER_TO_ACCEPTANCE_MANUAL
        );

        List<Contact> contactToUpdateListManual = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            domesticDeferredOfferToAcceptanceManual.values(),
            cadenceWrapper
        );
        if (!contactToUpdateListManual.isEmpty()) {
            contactToUpdateMap.putAll(contactToUpdateListManual);
        }

        return contactToUpdateMap;
    }
    
    /**
      * @description: Check if the contact is for Entry International Offer to Acceptance cadences
      *
      * @param Map<Id,Contact> mapOfContacts record to evaluate
      * @return Map<Id,Contact> of domestic acceptance contact
      */    
      public static Map<Id,Contact> getInternationalOfferToAcceptanceForEntry(Map<Id,Contact> internationalEntryContactMap) {
        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>();
        Map<Id, hed__Application__c> internationalOffertoAcceptanceManual = new Map<Id, hed__Application__c>();
        Map<Id, hed__Application__c> internationalOffertoAcceptanceAutomated = new Map<Id, hed__Application__c>();
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_AUTOMATED },
            applicantIdsWithCompletedCadence
        );
        Set<String> completedCadencesCopy = new Set<String>();

        // To group Automated and Manual Application
        for (hed__Application__c application : applicationList) {
            Boolean hasCompletedCadence = filteredApplicantIdsWithCompletedCadence.containsKey(application.hed__Applicant__c);
            boolean isStudyLinkRecordType = application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID;

            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            if (
                isStudyLinkRecordType &&
                internationalEntryContactMap.containsKey(application.hed__Applicant__c) &&
                ApplicationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_FOR_STUDYLINK.contains(application.Application_Status__c) &&
                NurturingTrackService.isDateWithinRange(
                    application.Calculated_Intake_Date__c,
                    CURRENT_INTAKE_PERIOD.get('START_DATE'),
                    CURRENT_INTAKE_PERIOD.get('END_DATE')) &&
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.INTERNATIONAL_TRACK_SUCCEEDING_OFFER_TO_ACCEPTANCE)
            ) {
                processCompletedInternationalOffertoAcceptanceAutomated(application, internationalOffertoAcceptanceAutomated, hasCompletedCadence);
                processCompletedInternationalOffertoAcceptanceManual(application, internationalOffertoAcceptanceManual, hasCompletedCadence);
            }
        }

        getCompletedInternationalOffertoAcceptanceAutomated(internationalEntryContactMap, internationalOffertoAcceptanceAutomated, contactToUpdateMap);
        processRemoveApplicationInLatestApplication(internationalOffertoAcceptanceManual, contactToUpdateMap);
        getCompletedInternationalOffertoAcceptanceManual(internationalEntryContactMap, internationalOffertoAcceptanceManual, contactToUpdateMap);
        return contactToUpdateMap;
    }

    private static void processCompletedInternationalOffertoAcceptanceAutomated(hed__Application__c application, Map<Id, hed__Application__c> internationalOffertoAcceptanceAutomated, Boolean hasCompletedCadence){
        if( !hasCompletedCadence){
            internationalOffertoAcceptanceAutomated.put(application.Id, application);
        }
    }

    private static void processCompletedInternationalOffertoAcceptanceManual(hed__Application__c application, Map<Id,hed__Application__c> internationalOffertoAcceptanceManual, Boolean hasCompletedCadence){

        if( hasCompletedCadence &&
            application.Is_Agent_Assisted__c == false &&
            nurturingTrackWithOffSetDaysMap.containsKey(NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL) &&
            nurturingTrackWithOffSetDaysMap.get(NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL).Key_Date_Offset_Days__c != null &&
            application.Calculated_Intake_Date__c.addDays(-(Integer)nurturingTrackWithOffSetDaysMap.get(NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL).Key_Date_Offset_Days__c) <= System.today()){
            internationalOffertoAcceptanceManual.put(application.Id, application);
        }
    }


    /**
     * @description Process Automated Application
     * @param Map<Id, Contact> internationalEntryContactMap
     * @param Map<Id, hed__Application__c> internationalOffertoAcceptanceAutomated
     * @param Map<Id, Contact> contactToUpdateMap
     */
    private static void getCompletedInternationalOffertoAcceptanceAutomated(Map<Id, Contact> internationalEntryContactMap,Map<Id, hed__Application__c> internationalOffertoAcceptanceAutomated,Map<Id, Contact> contactToUpdateMap){
        // Check Contact and Cadence Name if Automated is already Completed
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{
                NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_AUTOMATED
            },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(Contact.getSObjectType(), null,
                                                                                                                                    NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_AUTOMATED);

        // Check and Update Contacts Cadence Name
        List<Contact> completedManualCadenceByContactId = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            internationalOffertoAcceptanceAutomated.values(),
            cadenceWrapper
        );

        if(!completedManualCadenceByContactId.isEmpty()){
            contactToUpdateMap.putAll(completedManualCadenceByContactId);
        }
    }

     /**
     * @description Process Manual Application
     * @param Map<Id, Contact> internationalEntryContactMap
     * @param Map<Id, hed__Application__c> internationalOffertoAcceptanceManual
     * @param Map<Id, Contact> contactToUpdateMap
     */
    private static void getCompletedInternationalOffertoAcceptanceManual(Map<Id, Contact> internationalEntryContactMap,Map<Id, hed__Application__c> internationalOffertoAcceptanceManual,Map<Id, Contact> contactToUpdateMap){
        // Check Contact and Cadence Name if Automated is already Completed
        Map<Id, Set<String>> applicantWithCompletedCadenceAutomated = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{
                NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_AUTOMATED
            },
            applicantIdsWithCompletedCadence
        );
		
        Map<Id, hed__Application__c> latesetApplicationForManualCadence = new Map<Id, hed__Application__c>();

        // Get only the contact application that needs to be inserted if Automated is Completed
        for(Id applicationId : internationalOffertoAcceptanceManual.keySet()){
            hed__Application__c application = internationalOffertoAcceptanceManual.get(applicationId);
           
            if (applicantWithCompletedCadenceAutomated.containsKey(application.hed__Applicant__c)) {
                latesetApplicationForManualCadence.put(applicationId, application);
            }
        }

        // Check Contact and Cadence Name if Manual is already Completed
        Map<Id, Set<String>> applicantWithCompletedCadenceManual = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{
                NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL
            },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(Contact.getSObjectType(),
                                                                                                        '',
                                                                                                        NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL);

        // Check and Update Contacts Cadence Name
        List<Contact> contactToUpdateListManual = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            applicantWithCompletedCadenceManual,
            latesetApplicationForManualCadence.values(),
            cadenceWrapper
        );

        if(!contactToUpdateListManual.isEmpty()){
            contactToUpdateMap.putAll(contactToUpdateListManual);
        }
    }

    /**
     * @description Update domestic direct applicant contacts based on exit criteria
     * @param Map<Id, Contact> domesticExitContactMap
     * @return Map<Id, Contact> map of id to contact for batch processing
     */
    private static Map<Id, Contact> getExitInternationalOffertoAcceptance(
        Map<Id, Contact> internationalEntryContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();

        Set<String> offerStatus = new Set<String>{ 'Accepted', 'Declined by Applicant', 'Deferral Requested','Acceptance - Payment Received','Acceptance - No Payment Required','Acceptance - Pending More Information','Acceptance - Pending Payment','Conditional Acceptance','Withdrawn' };

        for (hed__Application__c application : applicationList) {
            boolean isStudyLinkRecordType = application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID;
            Boolean hasCalculatedCadence =
                (application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_AUTOMATED) ||
                (application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.INTERNATIONAL_OFFER_TO_ACCEPTANCE_MANUAL);
            if (
                internationalEntryContactMap.containsKey(application.hed__Applicant__c) &&
                isStudyLinkRecordType &&
                offerStatus.contains(application.Application_Status__c) &&
                hasCalculatedCadence && 
                NurturingTrackService.isDateWithinRange(
                    application.Calculated_Intake_Date__c,
                    CURRENT_INTAKE_PERIOD.get('START_DATE'),
                    CURRENT_INTAKE_PERIOD.get('END_DATE'))
            ) {
                contactsForUpdatingMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    
    /**
     * @description Updates contact if criteria is for Entry of Domestic Enrolment to Census cadence
     * @param Map<Id,Contact> domesticContactForCensusMap - domestic contacts to evaluate
     * @return Map<Id,Contact> - contacts to update
     */ 
    public static Map<Id,Contact> getDomesticEnrollmentToCensusForEntry(Map<Id,Contact> domesticContactForCensusMap){
        return getDomesticAndInternationalEnrollmentToCensusForEntry(domesticContactForCensusMap, true);
    }

    /**
     * @description Updates contact if criteria is for Entry of International Enrolment to Census cadence
     * @param Map<Id,Contact> internationalContactForCensusMap - international contacts to evaluate
     * @return Map<Id,Contact> - contacts to update
     */ 
    public static Map<Id,Contact> getInternationalEnrollmentToCensusForEntry(Map<Id,Contact> internationalContactForCensusMap){
        return getDomesticAndInternationalEnrollmentToCensusForEntry(internationalContactForCensusMap, false);
    }

    /**
     * @description Validate records and update contacts if criteria is for Entry of Domestic and International Enrolment to Census cadence
     * @param Map<Id,Contact> contactMap contacts to evaluate
     * @return Map<Id,Contact> contactToUpdateMap contacts to update
     */  
    public static Map<Id,Contact> getDomesticAndInternationalEnrollmentToCensusForEntry(Map<Id,Contact> contactMap, Boolean isDomestic){
        List<hed__Application__c>  filteredApplicationList = getFilteredApplicationListForDomesticEnrollmentToCensus(contactMap);
        Map<Id, hed__Application__c> applicationMap = new Map<Id, hed__Application__c>();
        Set<String> completedCadencesCopy = new Set<String>();
        Set<String> succeedingTrackToCheck = isDomestic?NurtureTrackConfigurationsDAO.DOMESTIC_TRACK_SUCCEEDING_CENSUS:new Set<String>();

        
        for (hed__Application__c application : filteredApplicationList) {
            
            boolean isOfferedProgramPlanAvailable = (application.Offered_Program_Plan__c != NULL && application.Offered_Program_Plan__r.Availability_Start_Date__c != NULL);
			Date keyOffsetDaysFromToday = null;
            
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            if(nurturingTrackWithOffSetDaysMap.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE)){
               keyOffsetDaysFromToday = Date.today().addDays((Integer)nurturingTrackWithOffSetDaysMap.get(NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE)?.Key_Date_Offset_Days__c); 
            }
            
            boolean isAppForEntry = validateAppRecordTypeForEnrollmentToCensus(isDomestic, application) &&
                                    isOfferedProgramPlanAvailable &&
                                    keyOffsetDaysFromToday != NULL &&
                                    application.Offered_Program_Plan__r.Availability_Start_Date__c <= keyOffsetDaysFromToday &&
                                    //make sure that there are no completed cadence against any succeeding cadence
                                    //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                                    !completedCadencesCopy.removeAll(succeedingTrackToCheck);
            
            if (isAppForEntry) {
                applicationMap.put(application.Id, application);
            }
        }

        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            contactMap.keySet(),
            new List<String>{NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE},
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            '',
            NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE
        );

        List<Contact> contactToUpdateList = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            applicationMap.values(),
            cadenceWrapper
        );

        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>(contactToUpdateList);
        return contactToUpdateMap;
    }

    /**
     * @description Update international direct applicant contacts based on exit criteria
     * @param Map<Id, Contact> internationalExitContactMap
     * @return Map<Id, Contact> map of id to contact for batch processing
     */
    private static Map<Id, Contact> getExitInternationalDirectApplicants(
        Map<Id, Contact> internationalExitContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();
        for (hed__Application__c application : applicationList) {
            Boolean hasCalculatedCadence =
                (application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_AUTOMATED) ||
                (application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.INTERNATIONAL_APP_SUBMISSION_DIRECT_APPLICANT_MANUAL);
            if (
                internationalExitContactMap.containsKey(application.hed__Applicant__c) &&
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID &&
                application.Application_Status__c == 'Submitted' &&
                hasCalculatedCadence
            ) {
                contactsForUpdatingMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    /**
     * @description: Check if the contact is for Exit of Domestic Acceptance To Enrollment cadences
     *
     * @param Map<Id,Contact> mapOfContacts record to evaluate
     * @return Map<Id,Contact> of domestic acceptance contact
     */
    public static Map<Id, Contact> getDomesticAcceptanceToEnrollmentForExit(
        Map<Id, Contact> domesticExitContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();
        Set<Id> existingContactIdOnApplicationToExit = new Set<Id>();

        if(!applicationList.isEmpty()){
            existingContactIdOnApplicationToExit.addAll(getDomesticAcceptanceToEnrollmentExitFilter(
                applicationList,
                'DomesticAcceptanceToEnrollment'
            ));
        }

        for (Id contactId : domesticExitContactMap.keySet()) {
            Boolean hasExistingApplicationToExit = existingContactIdOnApplicationToExit.contains(
                contactId
            );
            if (hasExistingApplicationToExit) {
                contactsForUpdatingMap.put(
                    contactId,
                    new Contact(id = contactId, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    /**
     * @description: Check if the contact is for Exit of Domestic Deferred Offer to Acceptance cadences
     *
     * @param Map<Id,Contact> mapOfContacts record to evaluate
     * @return Map<Id,Contact> of domestic acceptance contact
     */
    public static Map<Id, Contact> getDomesticDeferredOfferToAcceptanceForExit(
        Map<Id, Contact> domesticExitContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();
        Set<Id> existingContactIdOnApplicationToExit = new Set<Id>();
        
        if(!applicationList.isEmpty()){
            existingContactIdOnApplicationToExit.addAll(getDomesticDeferredOfferToAcceptanceExitFilter(
                applicationList,
                'DomesticDeferredOfferToAcceptance'
            ));
        }

        for (Id contactId : domesticExitContactMap.keySet()) {
            Boolean hasExistingApplicationToExit = existingContactIdOnApplicationToExit.contains(
                contactId
            );
            if (hasExistingApplicationToExit) {
                contactsForUpdatingMap.put(
                    contactId,
                    new Contact(id = contactId, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    /**
     * @description Update international direct applicant contacts based on exit criteria
     * @param Map<Id, Contact> internationalExitContactMap
     * @return Map<Id, Contact> map of id to contact for batch processing
     */
    private static Map<Id, Contact> getExitInternationalAcceptanceDepositNotPaid(
        Map<Id, Contact> internationalExitContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();
        Set<String> stydyLinkApplicationStatus = new Set<String>{
            'Accepted',
            'Accepted -  Deferral',
            'Withdrawn'
        };

        for (hed__Application__c application : applicationList) {
            Boolean hasCalculatedCadence =
                application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.INTERNATIONAL_ACCEPTANCE_DEPOSIT_NOT_PAID_MANUAL;
            if (
                internationalExitContactMap.containsKey(application.hed__Applicant__c) &&
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID &&
                stydyLinkApplicationStatus.contains(application.Application_Status__c) &&
                hasCalculatedCadence
            ) {
                contactsForUpdatingMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    /**
     * @description: Checks existing application records of the contact for entry
     *
     * @param List<hed__Application__c> List of Application record to evaluate
     * @param String Name of the cadence
     * @return Set<Id> contactIds
     */
    private static Set<Id> getDomesticAcceptanceToEnrollmentEntryFilter(
        List<hed__Application__c> applicationList
    ) {

        Set<Id> contactHasApplicationForEntry = new Set<Id>();
        /* samsApplicationWithQtacApplicantIdChecking(applicationList); */
        for (hed__Application__c app : applicationList) {
            processDomesticAcceptanceToEnrollmentEntryCriteria(
                app,
                contactHasApplicationForEntry
            );
        }

        return contactHasApplicationForEntry;
    }

    /**
     * @description: Checks existing application records of the contact for entry
     *
     * @param List<hed__Application__c> List of Application record to evaluate
     * @param String Name of the cadence
     * @return Set<Id> contactIds
     */
    private static Set<Id> getContactOnApplicationForDomesticDeferredOfferToAcceptanceEntryFilter(
        List<hed__Application__c> applicationList,
        String methodName
    ) {
        Set<Id> contactHasApplicationForEntry = new Set<Id>();
        for (hed__Application__c app : applicationList) {
            processDomesticDeferredOfferToAcceptanceEntryCriteria(
                app,
                methodName,
                contactHasApplicationForEntry
            );
        }

        return contactHasApplicationForEntry;
    }

    /**
     * @description: Checks existing application records of the contact for exit
     *
     * @param List<hed__Application__c> List of Application record to evaluate
     * @param String Name of the cadence
     * @return Set<Id> contactIds
     */
    private static Set<Id> getDomesticAcceptanceToEnrollmentExitFilter(
        List<hed__Application__c> applicationList,
        String methodName
    ) {
        Set<Id> contactHasApplicationForExit = new Set<Id>();
        for (hed__Application__c app : applicationList) {
            processDomesticAcceptanceToEnrollmentExitCriteria(
                app,
                methodName,
                contactHasApplicationForExit
            );
        }

        return contactHasApplicationForExit;
    }

    /**
     * @description: Checks existing application records of the contact for exit
     *
     * @param List<hed__Application__c> List of Application record to evaluate
     * @param String Name of the cadence
     * @return Set<Id> contactIds
     */
    private static Set<Id> getDomesticDeferredOfferToAcceptanceExitFilter(
        List<hed__Application__c> applicationList,
        String methodName
    ) {
        Set<Id> contactHasApplicationForExit = new Set<Id>();
        for (hed__Application__c app : applicationList) {
            processDomesticDeferredOfferToAcceptanceExitCriteria(
                app,
                methodName,
                contactHasApplicationForExit
            );
        }

        return contactHasApplicationForExit;
    }

    /**
     * @description Updates contact if criteria is for Exit of Domestic Enrolment to Census cadence
     * @param Map<Id,Contact> domesticContactForCensusMap - domestic contacts to evaluate
     * @return Map<Id,Contact> - contacts to update
     */ 
    private static Map<Id, Contact> getDomesticEnrollmentToCensusForExit(Map<Id, Contact> domesticContactForCensusMap) {
        return getDomesticAndInternationalEnrollmentToCensusForExit(domesticContactForCensusMap, true);
    }

    /**
     * @description Updates contact if criteria is for Exit of International Enrolment to Census cadence
     * @param Map<Id,Contact> internationalContactForCensusMap - international contacts to evaluate
     * @return Map<Id,Contact> - contacts to update
     */ 
    private static Map<Id, Contact> getInternationalEnrollmentToCensusForExit(Map<Id, Contact> internationalContactForCensusMap) {
        return getDomesticAndInternationalEnrollmentToCensusForExit(internationalContactForCensusMap, false);
    }

    /**
     * @description Validates the record and update contacts if criteria is for Exit of Domestic and International Enrolment to Census cadence
     * @param Map<Id,Contact> contactMap - contacts to evaluate
     * @param Boolean isDomestic - checker if student is domestic or international
     * @return Map<Id,Contact> contactsForUpdatingMap - contacts to update
     */  
    private static Map<Id, Contact> getDomesticAndInternationalEnrollmentToCensusForExit(Map<Id, Contact> contactMap, Boolean isDomestic) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();
        for (hed__Application__c application : applicationList) {
            Boolean hasCalculatedCadence =
                application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE;
            if(
                validateAppRecordTypeForEnrollmentToCensus(isDomestic, application) &&
                contactMap.containsKey(application.hed__Applicant__c) &&
                nurturingTrackForExitWithOffSetDaysMap.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE) &&
                application.Offered_Program_Plan__r.Availability_Start_Date__c != null && 
                application.Offered_Program_Plan__r.Availability_Start_Date__c <= System.today().addDays(-(Integer)nurturingTrackForExitWithOffSetDaysMap.get(NurtureTrackConfigurationsDAO.DOMESTIC_INTERNATIONAL_ENROLLMENT_CENSUS_CADENCE)?.Key_Date_Offset_Days__c) &&
                hasCalculatedCadence
            ) {
                contactsForUpdatingMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    private static Boolean validateAppRecordTypeForEnrollmentToCensus(Boolean isDomestic, hed__Application__c application){
        if(
            (isDomestic && (application.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID || application.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID)) ||
            (!isDomestic && application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID)
        ){
            return true;
        }
        return false;
    }
    
    private static void processDomesticAcceptanceToEnrollmentEntryCriteria(
        hed__Application__c app,
        Set<Id> contactHasApplicationForEntry
    ) {
        boolean isSAMSLegacyRecType = app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID;
        boolean isSAMSCiRecType = app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
            if (
                (isSAMSLegacyRecType || isSAMSCiRecType) &&
                app.Application_Status__c != 'Admitted' &&
                app.Is_Active__c &&
                app.Related_QTAC_Application__c != null &&
                app.Related_QTAC_Application__r.Offer_Status__c == 'Accepted'
            ) {
                contactHasApplicationForEntry.add(app.hed__Applicant__c);
            }
    }

    private static void processDomesticDeferredOfferToAcceptanceEntryCriteria(
        hed__Application__c app,
        String methodName,
        Set<Id> contactHasApplicationForEntry
    ) {

        boolean isValidRecordType = app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID || app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
        boolean isValidAdmissionProcess =   app.Admission_Process__c == ApplicationsDAO.ADMISSION_PROCESS_RTN_DEFER ||
                                            app.Admission_Process__c == ApplicationsDAO.ADMISSION_PROCESS_RTN_QTAC;
        boolean isValidStartDateForProgram =    app.Offered_Program_Plan__r.Availability_Start_Date__c != null &&
                                                app.Offered_Program_Plan__r.Availability_Start_Date__c.addDays(-21) <=
                                                System.today() &&
                                                app.Offered_Program_Plan__r.Availability_Start_Date__c >= System.today();

        boolean isAppForEntry = methodName == DOMESTIC_DEFFERED_OFFER_TO_ACCEPTANCE &&
                                isValidRecordType &&
                                isValidAdmissionProcess &&
                                app.Offer_Status__c == 'Offered' &&
                                isValidStartDateForProgram;

        if (isAppForEntry) {
            contactHasApplicationForEntry.add(app.hed__Applicant__c);
        }
    }

    private static void processDomesticAcceptanceToEnrollmentExitCriteria(
        hed__Application__c app,
        String methodName,
        Set<Id> contactHasApplicationForExit
    ) {
        boolean isSAMSLegacyRecType = app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID;
        boolean isSAMSCiRecType = app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
        Boolean hasCalculatedCadence =
                (app.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_AUTOMATED) ||
                (app.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL);
        if (methodName == DOMESTIC_ACCEPTANCE_TO_ENROLLMENT) {
            if (
                (isSAMSLegacyRecType || isSAMSCiRecType) &&
                (app.Application_Status__c == 'Admitted' ||
                app.Application_Status__c == 'Withdrawn' ||
                app.Offer_Status__c == 'Deferred') &&
                hasCalculatedCadence
            ) {
                contactHasApplicationForExit.add(app.hed__Applicant__c);
            }
        }
    }

    private static void processDomesticDeferredOfferToAcceptanceExitCriteria(
        hed__Application__c app,
        String methodName,
        Set<Id> contactHasApplicationForExit
    ) {
        Set<String> applicationOfferStatus = new Set<String>{'Accepted', 'Declined', 'Rescinded', 'Lapsed','Unoffered'};
        boolean isSAMSLegacyRecType = app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID;
        boolean isSAMSCiRecType = app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
        Boolean hasCalculatedCadence =
                app.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.DOMESTIC_DEFERRED_OFFER_TO_ACCEPTANCE_MANUAL;
        if (methodName == DOMESTIC_DEFFERED_OFFER_TO_ACCEPTANCE) {
            if (
                (isSAMSLegacyRecType || isSAMSCiRecType) &&
                applicationOfferStatus.contains(app.Offer_Status__c) &&
                hasCalculatedCadence
            ) {
                contactHasApplicationForExit.add(app.hed__Applicant__c);
            }
        }
    }

    /**
     * @description: Get the nurturing Track Records and set the key to Cadence Name
     *
     */
    private static void getFilteredNurturingTrackRecords() {
        for (Nurture_Track_Configuration__c nurture : NurtureTrackConfigurationsDAO.newInstance().getNurtureTrack(NurtureTrackConfigurationsDAO.NURTURE_FIELDS,'SYSTEM_MODE')) {
            if (nurture.Criteria_Type__c == 'Entry' && nurture.Enquiry_Category_L1__c != null && nurture.Lead_Score_Threshold__c != null) {
                nurturingTrackWithThresholdForEntry.put(nurture.Cadence_Name__c, nurture);
            }
            if (nurture.Key_Date_Offset_Days__c != null) {
                if(nurture.Criteria_Type__c == 'Entry'){
                    nurturingTrackWithOffSetDaysMap.put(nurture.Cadence_Name__c, nurture);
                } else if(nurture.Criteria_Type__c == 'Exit'){
                    nurturingTrackForExitWithOffSetDaysMap.put(nurture.Cadence_Name__c, nurture);
                }
            }
        }
    }

    /**
     * @description: Checks existing completed cadence records of the contact
     *
     * @param List<hed__Application__c> application records to evaluate
     * @param String cadence name to evaluate
     */
    private static Set<Id> getContactOnApplicationWithProgramPlan(
        List<hed__Application__c> applications,
        String cadenceName
    ) {
        Set<Id> contactIds = new Set<Id>();
        for (hed__Application__c app : applications) {
            if (cadenceName == NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL) {
                if (
                    app.Offered_Program_Plan__c != null &&
                    nurturingTrackWithOffSetDaysMap.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL) &&
                    nurturingTrackWithOffSetDaysMap.get(NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL)
                        ?.Key_Date_Offset_Days__c != null &&
                        app.Offered_Program_Plan__r.Availability_Start_Date__c!=null &&
                        app.Offered_Program_Plan__r.Availability_Start_Date__c.addDays(
                        -(Integer) nurturingTrackWithOffSetDaysMap.get(
                                NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL
                            )
                            ?.Key_Date_Offset_Days__c
                    ) <= System.today() &&
                    app.Offered_Program_Plan__r.Availability_Start_Date__c >= System.today()
                ) {
                    contactIds.add(app.hed__Applicant__c);
                }
            }
        }
        return contactIds;
    }

    /**
     * @description: Checks existing completed cadence records of the contact
     *
     * @param Set<Id> contactIds to evaluate    
     */
    private static Set<Id> getCompletedCadenceRecord(Set<Id> contactIds, String methodName) {
      
        Set<Id> contactIdOfCompletedCadence = new Set<Id>();
        List<Completed_Cadence__c> compCadenceList = CompletedCadencesDAO.newInstance()
            .getCompletedCadenceByContactIds(contactIds, 'SYSTEM_MODE');
        for (Completed_Cadence__c comCadence : compCadenceList) {
            if(comCadence.Nurture_Track_Configuration__r.Cadence_Name__c != null && comCadence.Nurture_Track_Configuration__r.Cadence_Name__c == methodName ){
                contactIdOfCompletedCadence.add(comCadence.Contact__c);
            }
        }
        return contactIdOfCompletedCadence;
    }

    private static void getCompletedCadenceForDomesticAcceptanceToEnrollmentAutomated(
        Map<Id, Contact> domesticEntryContactMap,
        Map<Id, hed__Application__c> domesticAcceptanceToEnrollmentAutomated,
        Map<Id, Contact> contactToUpdateMap
    ) {
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_AUTOMATED },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            null,
            NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_AUTOMATED
        );

        List<Contact> contactToUpdateListAutomated = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            domesticAcceptanceToEnrollmentAutomated.values(),
            cadenceWrapper
        );

        if (!contactToUpdateListAutomated.isEmpty()) {
            contactToUpdateMap.putAll(contactToUpdateListAutomated);
        }
    }

    private static void getCompletedCadenceForDomesticAcceptanceToEnrollmentManual(
        Map<Id, Contact> domesticEntryContactMap,
        Map<Id, hed__Application__c> domesticAcceptanceToEnrollmentManual,
        Map<Id, Contact> contactToUpdateMap
    ) {
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            null,
            NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_NOT_YET_ENROLLED_MANUAL
        );

        List<Contact> contactToUpdateListManual = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            domesticAcceptanceToEnrollmentManual.values(),
            cadenceWrapper
        );
        if (!contactToUpdateListManual.isEmpty()) {
            contactToUpdateMap.putAll(contactToUpdateListManual);
        }
    }

    /**
     * @description Validate records for Domestic Enrolment to Census Entry cadence
     * @param Map<Id,Contact> domesticExitContactMap domestic contacts to evaluate
     * @return Map<Id,Contact> contactsForUpdatingMap domestic contacts to update
     */ 
    private static List<hed__Application__c> getFilteredApplicationListForDomesticEnrollmentToCensus(Map<Id,Contact> domesticEntryContactMap){
        Set<Id> programEnrollmentIds = new Set<Id>();
        Map<Id, hed__Application__c> contactFromAppWithProgramEnrollmentMap = new Map<Id, hed__Application__c>();

        for (hed__Application__c application : applicationList) {
            if(domesticEntryContactMap.containsKey(application.hed__Applicant__c) && application.Program_Enrollment__c != null){
                programEnrollmentIds.add(application.Program_Enrollment__c);
                contactFromAppWithProgramEnrollmentMap.put(application.hed__Applicant__c, application);
            }
        }       

        Set<Id> filteredProgramEnrollmentIds = new Set<Id>();
        List<hed__Program_Enrollment__c> programEnrollmentList = ProgramEnrollmentsDAO.newInstance().getProgramEnrollmentsById(programEnrollmentIds, 'USER_MODE');
        for(hed__Program_Enrollment__c programEnrollment : programEnrollmentList){
            filteredProgramEnrollmentIds.add(programEnrollment.Id);
        }
        
        List<hed__Application__c> filteredApplicationList = new List<hed__Application__c>();
        List<hed__Course_Enrollment__c> courseEnrollmentList = CourseConnectionsDAO.newInstance().getCourseConnectionByProgramEnrollmentIds(filteredProgramEnrollmentIds, 'USER_MODE');
        for(hed__Course_Enrollment__c courseEnrollment : courseEnrollmentList){
            if(contactFromAppWithProgramEnrollmentMap.containsKey(courseEnrollment.hed__Contact__c) && courseEnrollment.Enrollment_Status__c != 'Enrolled'){
                filteredApplicationList.add(contactFromAppWithProgramEnrollmentMap.get(courseEnrollment.hed__Contact__c));
            }
        }

        return filteredApplicationList;
    }

    /**
     * @description Update domestic direct applicant contacts based on entry criteria
     * @param Map<Id, Contact> domesticEntryContactMap a map of ids to entry domestic contact records
     * @return Map<Id, Contact> map of id to updated contact records for batch processing
     */
    private static Map<Id, Contact> getEntryDomesticFirstOffertoAcceptance(
        Map<Id, Contact> domesticEntryContactMap
    ) {
        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>();
        Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceManual = new Map<Id, hed__Application__c>();
        Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceAutomated = new Map<Id, hed__Application__c>();
        Set<String> completedCadencesCopy = new Set<String>();
        Set<Id> applicationProgramUnderGrad = getapplicationProgramUnderGrad(applicationList);
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_AUTOMATED },
            applicantIdsWithCompletedCadence
        );
        // To group Automated and Manual Application
        for (hed__Application__c application : applicationList) {
            boolean isApplicationProgramUnderGrad = applicationProgramUnderGrad.contains(application.Id);
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();
            
            boolean isValidRecordType = application.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID || application.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
            boolean isValidAdmissionProcess =   application.Admission_Process__c != ApplicationsDAO.ADMISSION_PROCESS_RTN_DEFER && 
                                                application.Admission_Process__c != ApplicationsDAO.ADMISSION_PROCESS_RTN_QTAC;

            boolean isAppForEntry = isValidRecordType &&
                                    domesticEntryContactMap.containsKey(application.hed__Applicant__c) &&
                                    application.Offer_Status__c == ApplicationsDAO.STATUS_OFFERED &&
                                    isValidAdmissionProcess &&
                                    application.hed__Application_Date__c != null &&
                                    //make sure that there are no completed cadence against any succeeding cadence
                                    //this should return true if one of the succeeding cadence is already in completedCadencesCopy
                                    !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.DOMESTIC_TRACK_SUCCEEDING_FIRST_OFFER) &&
                                    isApplicationProgramUnderGrad;
            if (isAppForEntry) {
                
                Boolean hasAutomatedCompletedCadence = filteredApplicantIdsWithCompletedCadence.containsKey(application.hed__Applicant__c);

                processCompletedDomesticFirstOffertoAcceptance(
                    application,
                    domesticFirstOffertoAcceptanceManual,
                    domesticFirstOffertoAcceptanceAutomated,
                    hasAutomatedCompletedCadence
                );
            }
        }

        Map<Id, hed__Application__c> latestApplicationAutomated = new Map<Id, hed__Application__c>();
        Map<Id, hed__Application__c> latestApplicationManual = new Map<Id, hed__Application__c>();

        processLatestApplicationDate(
            domesticFirstOffertoAcceptanceAutomated,
            latestApplicationAutomated
        );
        processLatestApplicationDate(domesticFirstOffertoAcceptanceManual, latestApplicationManual);
        getCompletedDomesticFirstOffertoAcceptanceAutomated(
            domesticEntryContactMap,
            latestApplicationAutomated,
            contactToUpdateMap
        );
        processRemoveApplicationInLatestApplication(latestApplicationManual, contactToUpdateMap);
        getCompletedDomesticFirstOffertoAcceptanceManual(
            domesticEntryContactMap,
            latestApplicationManual,
            contactToUpdateMap
        );

        return contactToUpdateMap;
    }

    /**
     * @description Update domestic direct applicant contacts based on exit criteria
     * @param Map<Id, Contact> domesticExitContactMap
     * @return Map<Id, Contact> map of id to contact for batch processing
     */
    private static Map<Id, Contact> getExitDomesticFirstOffertoAcceptance(
        Map<Id, Contact> domesticExitContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();

        Set<String> offerStatus = new Set<String>{ 'Accepted', 'Declined', 'Deferred', 'Lapsed', 'Admitted'};

        for (hed__Application__c application : applicationList) {
            boolean isSAMSLegacyRecType =
                application.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID;
            boolean isSAMSCiRecType =
                application.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
            Boolean hasCalculatedCadence =
                (application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_AUTOMATED) ||
                (application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_MANUAL);
            if (
                domesticExitContactMap.containsKey(application.hed__Applicant__c) &&
                (isSAMSLegacyRecType || isSAMSCiRecType) &&
                offerStatus.contains(application.Offer_Status__c) &&
                hasCalculatedCadence
            ) {
                contactsForUpdatingMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }

    /**
     * @description Get only latest application by date Automated
     * @param Map<Id, hed__Application__c> domesticFirstOffertoAcceptance
     * @param Map<Id, hed__Application__c> latestApplicationAutomated
     */
    private static void processLatestApplicationDate(
        Map<Id, hed__Application__c> domesticFirstOffertoAcceptance,
        Map<Id, hed__Application__c> latestApplication
    ) {
        Map<Id, hed__Application__c> filterByContactApplication = new Map<Id, hed__Application__c>();

        for (Id applicationId : domesticFirstOffertoAcceptance.keySet()) {
            Id contactId = domesticFirstOffertoAcceptance.get(applicationId).hed__Applicant__c;
            hed__Application__c application = domesticFirstOffertoAcceptance.get(applicationId);

            if (
                !filterByContactApplication.containsKey(contactId) ||
                (filterByContactApplication.containsKey(contactId) &&
                (application.hed__Application_Date__c >
                filterByContactApplication.get(contactId).hed__Application_Date__c))
            ) {
                filterByContactApplication.put(
                    contactId,
                    domesticFirstOffertoAcceptance.get(applicationId)
                );
            }
        }

        for (Id contactId : filterByContactApplication.keySet()) {
            hed__Application__c application = filterByContactApplication.get(contactId);
            latestApplication.put(application.Id, application);
        }
    }

    /**
     * @description Check 2 days after offer received for Manual else Automated
     * @param Map<Id, hed__Application__c> application
     * @param Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceManual
     * @param Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceAutomated
     */
    private static void processCompletedDomesticFirstOffertoAcceptance(
        hed__Application__c application,
        Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceManual,
        Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceAutomated,
        Boolean hasAutomatedCompletedCadence
    ) {

        if (hasAutomatedCompletedCadence){
            domesticFirstOffertoAcceptanceManual.put(application.Id, application); // Group Manual Application
        } else {
            domesticFirstOffertoAcceptanceAutomated.put(application.Id, application); // Group Automated Application
        }
    }

    /**
     * @description Remove in list manual application if Contact Id is in Automated list insertion
     * @param Map<Id, hed__Application__c> latestApplicationManual
     * @param Map<Id, Contact> contactToUpdateMap
     */
    private static void processRemoveApplicationInLatestApplication(
        Map<Id, hed__Application__c> latestApplicationManual,
        Map<Id, Contact> contactToUpdateMap
    ) {
        for (Id applicationId : latestApplicationManual.keySet()) {
            hed__Application__c application = latestApplicationManual.get(applicationId);

            if (contactToUpdateMap.containsKey(application.hed__Applicant__c)) {
                latestApplicationManual.remove(applicationId);
            }
        }
    }

    /**
     * @description Process Automated Application
     * @param Map<Id, Contact> domesticEntryContactMap
     * @param Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceAutomated
     * @param Map<Id, Contact> contactToUpdateMap
     */
    private static void getCompletedDomesticFirstOffertoAcceptanceAutomated(
        Map<Id, Contact> domesticEntryContactMap,
        Map<Id, hed__Application__c> domesticFirstOffertoAcceptanceAutomated,
        Map<Id, Contact> contactToUpdateMap
    ) {
        // Check Contact and Cadence Name if Automated is already Completed
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_AUTOMATED },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            null,
            NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_AUTOMATED
        );

        // Check and Update Contacts Cadence Name
        List<Contact> completedManualCadenceByContactId = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            domesticFirstOffertoAcceptanceAutomated.values(),
            cadenceWrapper
        );

        if (!completedManualCadenceByContactId.isEmpty()) {
            contactToUpdateMap.putAll(completedManualCadenceByContactId);
        }
    }

    /**
     * @description Process Manual Application
     * @param Map<Id, Contact> domesticEntryContactMap
     * @param Map<Id, hed__Application__c> latestApplicationManual
     * @param Map<Id, Contact> contactToUpdateMap
     */
    private static void getCompletedDomesticFirstOffertoAcceptanceManual(
        Map<Id, Contact> domesticEntryContactMap,
        Map<Id, hed__Application__c> latestApplicationManual,
        Map<Id, Contact> contactToUpdateMap
    ) {
        // Check Contact and Cadence Name if Automated is already Completed
        Map<Id, Set<String>> applicantIdsWithCompletedCadenceAutomated = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_AUTOMATED },
            applicantIdsWithCompletedCadence
        );

        Map<Id, hed__Application__c> latesetApplicationForManualCadence = new Map<Id, hed__Application__c>();

        // Get only the contact application that needs to be inserted if Automated is Completed
        for (Id applicationId : latestApplicationManual.keySet()) {
            hed__Application__c application = latestApplicationManual.get(applicationId);

            if (applicantIdsWithCompletedCadenceAutomated.containsKey(application.hed__Applicant__c)) {
                latesetApplicationForManualCadence.put(applicationId, application);
            }
        }

        // Check Contact and Cadence Name if Manual is already Completed
        Map<Id, Set<String>> applicantIdsWithCompletedCadenceManual = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_MANUAL },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            '',
            NurtureTrackConfigurationsDAO.DOMESTIC_FIRST_OFFER_TO_ACCEPTANCE_MANUAL
        );

        // Check and Update Contacts Cadence Name
        List<Contact> contactToUpdateListManual = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            applicantIdsWithCompletedCadenceManual,
            latesetApplicationForManualCadence.values(),
            cadenceWrapper
        );

        if (!contactToUpdateListManual.isEmpty()) {
            contactToUpdateMap.putAll(contactToUpdateListManual);
        }
    }

    /**
     * @description Update Domestic Offer Lapsed contacts based on entry criteria
     * @param Map<Id, Contact> domesticEntryContactMap a map of ids to entry domestic contact records
     * @return Map<Id, Contact> map of ids to updated contact records for batch processing
     */
    private static Map<Id, Contact> getEntryDomesticOfferLapsed(
        Map<Id, Contact> domesticEntryContactMap
    ) {
        Map<Id, Contact> contactsToUpdateMap = new Map<Id, Contact>();
        Map<Id, hed__Application__c> applicantAutomated = new Map<Id, hed__Application__c>();
        Map<Id, hed__Application__c> applicantManual = new Map<Id, hed__Application__c>();

        for (hed__Application__c application : applicationList) {
            Boolean isSAMSApplicant =
                (application.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID) ||
                (application.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID);
            
            if (
                application.Offer_Status__c != null &&
                application.Offer_Lapse_Date__c != null &&
                isSAMSApplicant &&
                domesticEntryContactMap.containsKey(application.hed__Applicant__c) &&
                application.Offer_Status__c == 'Lapsed'
            ) {
                processEntryDomesticOfferLapsed(application, applicantAutomated, applicantManual);
            }
        }

        processApplicantAutomated(applicantAutomated, contactsToUpdateMap);
        processApplicantManual(applicantManual, contactsToUpdateMap);

        return contactsToUpdateMap;
    }

    /**
     * @description Update international direct applicant contacts based on entry criteria
     * @param Map<Id, Contact> internationEntryContactMap a map of ids to entry international contact records
     * @return Map<Id, Contact> map of id to updated contact records for batch processing
     */
    public static Map<Id, Contact> getEntryInternationalApplicationToOffer(
        Map<Id, Contact> internationalEntryContactMap
    ) {
        Double offsetDays = nurturingTrackWithOffSetDaysMap.get(NurtureTrackConfigurationsDAO.INTERNATIONAL_APPLICATION_TO_OFFER_MANUAL)?.Key_Date_Offset_Days__c;
        Map<Id, hed__Application__c> internationalApplicantsToOffer = new Map<Id, hed__Application__c>();
        Set<String> completedCadencesCopy = new Set<String>();
        for (hed__Application__c application : applicationList) {
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(application.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(application.hed__Applicant__c)):new Set<String>();

            Boolean withinOffSetDays = false;
            if(
                offsetDays != null &&
                application.Calculated_Intake_Date__c  != null
            ){
                withinOffSetDays = setwithinOffSetDays(application, offsetDays);
            }
            if (checkAppInternationalApplicationToOffer(application) &&
                internationalEntryContactMap.containsKey(application.hed__Applicant__c) &&
                withinOffSetDays &&
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.INTERNATIONAL_TRACK_SUCCEEDING_APP_TO_OFFER)
            ) {
            	internationalApplicantsToOffer.put(application.Id, application);
            }
        }
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{
                NurtureTrackConfigurationsDAO.INTERNATIONAL_APPLICATION_TO_OFFER_MANUAL
            },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            '',
            NurtureTrackConfigurationsDAO.INTERNATIONAL_APPLICATION_TO_OFFER_MANUAL
        );

        List<Contact> contactToUpdateList = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            internationalApplicantsToOffer.values(),
            cadenceWrapper
        );

        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>(contactToUpdateList);
        return contactToUpdateMap;
    }

    /**
     * @description: Check if the contact is for Entry of Domestic Strong Interest Pre-Application cadences
     *
     * @param Map<Id,Contact> mapOfContacts record to evaluate
     * @return Map<Id,Contact> of domestic acceptance contact
     */
    private static Map<Id, Contact> getDomesticStrongInterestPreApplicationForEntry(
        Map<Id, Contact> domesticEntryContactMap
    ) {
        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>();
        Set<Id> existingContactIdOnApplication = getContactOnApplicationForDomesticStrongInterestPreApplicationEntryFilter(applicationListForStrongInterest,domesticEntryContactMap.keySet());
        Set<Id> existingCaseFromContact = getCaseRecordsFromContact(domesticEntryContactMap.keySet());
        Set<Id> contactIdsWithApplication = getContactIdsWithApplication(applicationList);
        Set<String> completedCadencesCopy = new Set<String>();
        Map<Id, Set<String>> contactsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED },
            applicantIdsWithCompletedCadence
        );

        Map<Id, Set<String>> contactsWithCompletedCadenceManual = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL },
            applicantIdsWithCompletedCadence
        );

        for (Contact contact : domesticEntryContactMap.values()){
            Boolean contacHasExistingApplication = contactIdsWithApplication.contains(contact.Id);
            Boolean hasInActiveApplication = existingContactIdOnApplication.contains(contact.Id);
            Boolean hasExistingCaseFromContact = existingCaseFromContact.contains(contact.Id);
            Boolean hasExistingCompletedCadence = contactsWithCompletedCadence.containsKey(contact.Id);
            Boolean hasExistingCompletedCadenceManual = contactsWithCompletedCadenceManual.containsKey(contact.Id);

            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(contact.Id)?new Set<String>(applicantIdsWithAllCompletedCadence.get(contact.Id)):new Set<String>();
            if ((!contacHasExistingApplication || hasInActiveApplication) && 
                hasExistingCaseFromContact && 
                !hasExistingCompletedCadenceManual &&
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in completedCadencesCopy
                !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.DOMESTIC_TRACK_SUCCEEDING_STRONG_INTEREST))
            {
                contactToUpdateMap.put(
                        contact.Id, 
                        new Contact(
                            Id = contact.Id,
                            Calculated_Cadence__c = hasExistingCompletedCadence ?
                                NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL :
                                NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED
                        )
                    );
            }
        }
        
        return contactToUpdateMap;
    }

    /**
     * @description Update contact with the “Domestic Accepted and Admitted” when the entry criteria is fulfilled.
     * @param Map<Id, Contact> domesticContact a map of ids to entry contact records
     * @return Map<Id, Contact> map of id to updated contact records for batch processing
     */
    private static Map<Id, Contact> getEntryDomesticAcceptedAndAdmitted(
        Map<Id, Contact> domesticEntryContactMap
    ) {
        Map<Id, hed__Application__c> domesticAcceptedApplicants = new Map<Id, hed__Application__c>();
        Set<String> completedCadencesCopy = new Set<String>();
        Set<Id> applicationProgramUnderGrad = getapplicationProgramUnderGrad(applicationList);
        for (hed__Application__c app : applicationList) {

            Boolean isSAMSApplication = (app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID || app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID);
            Boolean isProgramEnrollmentAdmitted = (app.Program_Enrollment__c != NULL && String.isNotBlank(app.Program_Enrollment__r.Enrollment_Status__c));
            Boolean isSAMSLatestApplication = (app.Calculated_Intake_Date__c != NULL && app.Calculated_Intake_Date__c > Date.today());
            boolean isApplicationProgramUnderGrad = applicationProgramUnderGrad.contains(app.Id);

            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(app.hed__Applicant__c)?new Set<String>(applicantIdsWithAllCompletedCadence.get(app.hed__Applicant__c)):new Set<String>();
            
            boolean isAppForEntry = isSAMSApplication &&
                                    domesticEntryContactMap.containsKey(app.hed__Applicant__c) &&
                                    isProgramEnrollmentAdmitted &&
                                    isSAMSLatestApplication &&
                                    app.Program_Enrollment__r.Enrollment_Status__c =='Admitted' &&
                                    //make sure that there are no completed cadence against any succeeding cadence
                                    //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                                    !completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.DOMESTIC_TRACK_SUCCEEDING_ACCEPTED_ADMITTED) &&
                                    isApplicationProgramUnderGrad;
            if (isAppForEntry) {
                domesticAcceptedApplicants.put(app.Id, app);
            }
        }

        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_AND_ADMITTED_MANUAL },
            applicantIdsWithCompletedCadence
        );

        NurturingTrackService.CadenceWrapper cadenceWrapper = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            null,
            NurtureTrackConfigurationsDAO.DOMESTIC_ACCEPTED_AND_ADMITTED_MANUAL
        );

        List<Contact> contactToUpdateList = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            domesticAcceptedApplicants.values(),
            cadenceWrapper
        );

        Map<Id, Contact> contactToUpdateMap = new Map<Id, Contact>(contactToUpdateList);
        return contactToUpdateMap;
    }

    /**
     * @description: Check if the contact is for Exit of Domestic Deferred Offer to Acceptance cadences
     *
     * @param Map<Id,Contact> mapOfContacts record to evaluate
     * @return Map<Id,Contact> of domestic acceptance contact
     */
    private static Map<Id, Contact> getDomesticStrongInterestPreApplicationForExit(
        Map<Id, Contact> domesticExitContactMap
    ) {
        Map<Id, Contact> contactsForUpdatingMap = new Map<Id, Contact>();
        Set<Id> existingContactIdOnApplicationToExit = new Set<Id>();
        List<String> cadenceNames = new List<String>{
            NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED, 
            NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL
        };
        
        if(!applicationList.isEmpty()){
            existingContactIdOnApplicationToExit.addAll(getContactOnApplicationForDomesticStrongInterestPreApplicationExitFilter(
                applicationListForStrongInterest
            ));
        }
        for (Id contactId : domesticExitContactMap.keySet()) {
            Boolean hasExistingApplicationToExit = existingContactIdOnApplicationToExit.contains(
                contactId
            );
            //check if current contact is in domestic strong interest cadence
            if ( cadenceNames.contains(domesticExitContactMap.get(contactId).Calculated_Cadence__c) && 
                (hasExistingApplicationToExit || domesticExitContactMap.get(contactId).HasOptedOutOfEmail)) {
                contactsForUpdatingMap.put(
                    contactId,
                    new Contact(id = contactId, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsForUpdatingMap;
    }


    /**
     * @description: Checks existing application records of the contact for entry
     *
     * @param List<hed__Application__c> List of Application record to evaluate
     * @param String Name of the cadence
     * @return Set<Id> contactIds
     */
    private static Set<Id> getContactOnApplicationForDomesticStrongInterestPreApplicationEntryFilter(
        List<hed__Application__c> applicationList,
        Set<Id> contactIdSet
    ) {
        Set<Id> contactHasApplicationForEntry = new Set<Id>();
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED },
            applicantIdsWithCompletedCadence
        );
        for (hed__Application__c app : applicationList) {
            boolean isSAMSLegacyRecType = app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID;
            boolean isSAMSCiRecType = app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
            boolean isQTACRecType = app.RecordTypeId == ApplicationsDAO.QTAC_RECTYPE_ID;
            if(isSAMSLegacyRecType || isSAMSCiRecType){
                processSamsDomesticStrongInterestPreApplicationEntryCriteria(app,contactHasApplicationForEntry,filteredApplicantIdsWithCompletedCadence.containsKey(app.hed__Applicant__c));
            }
            else if(isQTACRecType){
                processQtacDomesticStrongInterestPreApplicationEntryCriteria(app,contactHasApplicationForEntry,filteredApplicantIdsWithCompletedCadence.containsKey(app.hed__Applicant__c));
            }
        }
        return contactHasApplicationForEntry;
    }

    private static void processSamsDomesticStrongInterestPreApplicationEntryCriteria(
        hed__Application__c app,
        Set<Id> contactHasApplicationForEntry,
        boolean hasCompletedCadence
    ) {

        if(!hasCompletedCadence && checkSamsDomesticStrongInterestPreApplicationAutomated(app)){
                contactHasApplicationForEntry.add(app.hed__Applicant__c);
        }
        else if(hasCompletedCadence && checkSamsDomesticStrongInterestPreApplicationManual(app)){
                contactHasApplicationForEntry.add(app.hed__Applicant__c);
        }
    }

    private static boolean checkSamsDomesticStrongInterestPreApplicationAutomated(hed__Application__c app){
        Boolean isAppStatusValid = app.Application_Status__c == 'Admitted' || app.Application_Status__c == 'Unsuccessful' || app.Application_Status__c == 'Withdrawn';
        if ((app.Offer_Status__c == 'Deferred' || isAppStatusValid) &&
            app.hed__Applicant__r.Lead_Score__c != null &&
            nurturingTrackWithThresholdForEntry.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED) &&
            app.hed__Applicant__r.Lead_Score__c > nurturingTrackWithThresholdForEntry.get(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED).Lead_Score_Threshold__c &&
            (app.hed__Application_Date__c <= System.Now() && app.hed__Application_Date__c >= System.Now().addYears(-3))
        ) {
            return true;
        }
        return false;
    }

    private static boolean checkSamsDomesticStrongInterestPreApplicationManual(hed__Application__c app){
        Boolean isAppStatusValid = app.Application_Status__c == 'Admitted' || app.Application_Status__c == 'Unsuccessful' || app.Application_Status__c == 'Withdrawn';
        if ((app.Offer_Status__c == 'Deferred' || isAppStatusValid) &&
            app.hed__Applicant__r.Lead_Score__c != null &&
            nurturingTrackWithThresholdForEntry.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL) &&
            app.hed__Applicant__r.Lead_Score__c > nurturingTrackWithThresholdForEntry.get(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL).Lead_Score_Threshold__c &&
            (app.hed__Application_Date__c <= System.Now() && app.hed__Application_Date__c >= System.Now().addYears(-3))
        ) {
            return true;
        }
        return false;
    }

    private static void processQtacDomesticStrongInterestPreApplicationEntryCriteria(
        hed__Application__c app,
        Set<Id> contactHasApplicationForEntry,
        boolean hasCompletedCadence) {
        if(!hasCompletedCadence && checkQtacDomesticStrongInterestPreApplicationAutomated(app)){
            contactHasApplicationForEntry.add(app.hed__Applicant__c);
        }
        else if(hasCompletedCadence && checkQtacDomesticStrongInterestPreApplicationManual(app)){
            contactHasApplicationForEntry.add(app.hed__Applicant__c);
        }
    }

    private static boolean checkQtacDomesticStrongInterestPreApplicationAutomated(hed__Application__c app){
        if (!app.Is_Active__c &&
            app.hed__Applicant__r.Lead_Score__c != null &&
            nurturingTrackWithThresholdForEntry.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED) &&
            app.hed__Applicant__r.Lead_Score__c > nurturingTrackWithThresholdForEntry.get(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED).Lead_Score_Threshold__c &&
            (app.CreatedDate <= System.Now() && app.CreatedDate >= System.Now().addYears(-3))
        ) {
            return true;
        }
        return false;
    }

    private static boolean checkQtacDomesticStrongInterestPreApplicationManual(hed__Application__c app){
        if (!app.Is_Active__c &&
            app.hed__Applicant__r.Lead_Score__c != null &&
            nurturingTrackWithThresholdForEntry.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL) &&
            app.hed__Applicant__r.Lead_Score__c > nurturingTrackWithThresholdForEntry.get(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL).Lead_Score_Threshold__c &&
            (app.CreatedDate <= System.Now() && app.CreatedDate >= System.Now().addYears(-3))
        ) {
            return true;
        }
        return false;
    }

    private static Set<Id> getContactOnApplicationForDomesticStrongInterestPreApplicationExitFilter(List<hed__Application__c> applicationList){
        Set<Id> contactHasApplicationForExit = new Set<Id>();
        for (hed__Application__c app : applicationList) {
            boolean isSAMSLegacyRecType = app.RecordTypeId == ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID;
            boolean isSAMSCiRecType = app.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID;
            boolean isQTACRecType = app.RecordTypeId == ApplicationsDAO.QTAC_RECTYPE_ID;
            if(app.Application_Status__c == 'Submitted' && (isSAMSLegacyRecType || isSAMSCiRecType || isQTACRecType)){
                contactHasApplicationForExit.add(app.hed__Applicant__c);
            }
        }
        return contactHasApplicationForExit;
    }

    private static Set<Id> getCaseRecordsFromContact(Set<Id> contactIds){
        Set<Id> caseFromContactIds = new Set<Id>();
        List<Case> caseList = new List<Case>();
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = new Map<Id, Set<String>>();

        if(nurturingTrackWithThresholdForEntry.containsKey(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED)){
            filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
                domesticEntryContactMap.keySet(),
                new List<String>{ NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED },
                applicantIdsWithCompletedCadence
            );
            caseList = CasesDAO.newInstance().getCasesByContactIds(contactIds, AccessLevel.SYSTEM_MODE);
        }

        for(Case caseRec : caseList){
            if(!filteredApplicantIdsWithCompletedCadence.containsKey(caseRec.ContactId) &&
                checkCaseCreatedDate(caseRec) &&
                nurturingTrackWithThresholdForEntry.get(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED).Enquiry_Category_L1__c.split(';').contains(caseRec.Category__c)
            ){
                caseFromContactIds.add(caseRec.ContactId);
            }
            else if(filteredApplicantIdsWithCompletedCadence.containsKey(caseRec.ContactId) &&
                checkCaseCreatedDate(caseRec) &&
                nurturingTrackWithThresholdForEntry.get(NurtureTrackConfigurationsDAO.DOMESTIC_STRONG_INTEREST_PRE_APPLICATION_MANUAL).Enquiry_Category_L1__c.split(';').contains(caseRec.Category__c)
            ){
                caseFromContactIds.add(caseRec.ContactId);
            }
        }
        return caseFromContactIds;
    }

    private static boolean checkCaseCreatedDate(Case caseRec){
        return (caseRec.CreatedDate <= System.Now() && caseRec.CreatedDate >= System.Now().addMonths(-3) && caseRec.Category__c != null);
    }

    private static Set<Id> getContactIdsWithApplication(List<hed__Application__c> applications){
        Set<Id> applicationContactIds = new Set<Id>();
        for(hed__Application__c app : applications){
            applicationContactIds.add(app.hed__Applicant__c);
        }
        return applicationContactIds;
    }   



    /**
     * @description Update Domestic Offer Lapsed contacts based on exit criteria
     * @param Map<Id, Contact> domesticExitContactMap a map of ids to exit domestic contact records
     * @return Map<Id, Contact> map of ids to updated contact records for batch processing
     */
    private static Map<Id, Contact> getExitDomesticOfferLapsed(
        Map<Id, Contact> domesticExitContactMap
    ) {
        Map<Id, Contact> contactsToUpdateMap = new Map<Id, Contact>();
        for (hed__Application__c application : applicationList) {
            Boolean isSAMSApplicant = (application.RecordTypeId ==
            ApplicationsDAO.SAMS_LEGACY_RECTYPE_ID ||
            application.RecordTypeId == ApplicationsDAO.SAMS_CIANYWHERE_RECTYPE_ID);
            Boolean hasDomesticOfferLapsedCadence =
                (application.hed__Applicant__r.Calculated_Cadence__c ==
                DOMESTIC_OFFER_LAPSED_AUTOMATED) ||
                (application.hed__Applicant__r.Calculated_Cadence__c ==
                DOMESTIC_OFFER_LAPSED_MANUAL);
            // Check if today's date is greater than the application last admission date            
            Boolean isTodayGreaterThanLastAdmissionDate = Date.today() >= application.Applied_Intake_Study_Period__r.Last_Admission_Date__c;
            
            if (
                isSAMSApplicant &&
                hasDomesticOfferLapsedCadence &&
                domesticExitContactMap.containsKey(application.hed__Applicant__c) &&
                application.Offer_Status__c != 'Lapsed' &&
                isTodayGreaterThanLastAdmissionDate
            ) {
                contactsToUpdateMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsToUpdateMap;
    }

    /**
     * @description Update Domestic Offer Lapsed contacts based on exit criteria
     * @param Map<Id, Contact> domesticExitContactMap a map of ids to exit domestic contact records
     * @return Map<Id, Contact> map of ids to updated contact records for batch processing
     */
    private static Map<Id, Contact> getExitInternationalApplicationToOffer(
        Map<Id, Contact> internationalExitContactMap
    ) {
        Map<Id, Contact> contactsToUpdateMap = new Map<Id, Contact>();
        for (hed__Application__c application : applicationList) {
            if (
                application.hed__Applicant__r.Calculated_Cadence__c == NurtureTrackConfigurationsDAO.INTERNATIONAL_APPLICATION_TO_OFFER_MANUAL &&
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID &&
                internationalExitContactMap.containsKey(application.hed__Applicant__c) &&
                !ApplicationsDAO.INTL_EXIT_APPLICATION_TO_OFFER_STATUSES_FOR_STUDYLINK.contains(application.Application_Status__c)
            ) {
                contactsToUpdateMap.put(
                    application.hed__Applicant__c,
                    new Contact(Id = application.hed__Applicant__c, Calculated_Cadence__c = '')
                );
            }
        }
        return contactsToUpdateMap;
    }

    private static void processEntryDomesticOfferLapsed(
        hed__Application__c application,
        Map<Id, hed__Application__c> applicantAutomated,
        Map<Id, hed__Application__c> applicantManual
    ) {
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ DOMESTIC_OFFER_LAPSED_AUTOMATED },
            applicantIdsWithCompletedCadence
        );

        boolean hasAutomatedOffsetDays =
            nurturingTrackWithOffSetDaysMap.containsKey(DOMESTIC_OFFER_LAPSED_AUTOMATED) &&
                nurturingTrackWithOffSetDaysMap.get(DOMESTIC_OFFER_LAPSED_AUTOMATED)
                    .Key_Date_Offset_Days__c != null;

        boolean hasManualOffsetDays =
            nurturingTrackWithOffSetDaysMap.containsKey(DOMESTIC_OFFER_LAPSED_MANUAL) &&
                nurturingTrackWithOffSetDaysMap.get(DOMESTIC_OFFER_LAPSED_MANUAL)
                    .Key_Date_Offset_Days__c != null;

        if (hasAutomatedOffsetDays) {
            Integer offsetDaysAutomated = (Integer) nurturingTrackWithOffSetDaysMap.get(
                    DOMESTIC_OFFER_LAPSED_AUTOMATED
                )
                .Key_Date_Offset_Days__c;

            Date offsetOfferLapsedDateAutomated = application.Offer_Lapse_Date__c.addDays(
                offsetDaysAutomated
            );

            if (System.today() >= offsetOfferLapsedDateAutomated) {
                applicantAutomated.put(application.Id, application);
            }
        }

        if (hasManualOffsetDays) {
            Integer offsetDaysManual = (Integer) nurturingTrackWithOffSetDaysMap.get(
                    DOMESTIC_OFFER_LAPSED_MANUAL
                )
                .Key_Date_Offset_Days__c;

            Date offsetOfferLapsedDateManual = application.Offer_Lapse_Date__c.addDays(
                offsetDaysManual
            );

            if (
                System.today() >= offsetOfferLapsedDateManual &&
                filteredApplicantIdsWithCompletedCadence.containsKey(application.hed__Applicant__c)
            ) {
                applicantManual.put(application.Id, application);
            }
        }
    }

    private static void processApplicantAutomated(
        Map<Id, hed__Application__c> applicantAutomated,
        Map<Id, Contact> contactsToUpdateMap
    ) {
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ DOMESTIC_OFFER_LAPSED_AUTOMATED },
            applicantIdsWithCompletedCadence
        );
        NurturingTrackService.CadenceWrapper cadenceWrapperAutomated = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            DOMESTIC_OFFER_LAPSED_AUTOMATED,
            null
        );
        List<Contact> contactToUpdateListAutomated = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            applicantAutomated.values(),
            cadenceWrapperAutomated
        );
        contactsToUpdateMap.putAll(new Map<Id, Contact>(contactToUpdateListAutomated));
    }

    private static void processApplicantManual(
        Map<Id, hed__Application__c> applicantManual,
        Map<Id, Contact> contactsToUpdateMap
    ) {
        Map<Id, Set<String>> filteredApplicantIdsWithCompletedCadence = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            domesticEntryContactMap.keySet(),
            new List<String>{ DOMESTIC_OFFER_LAPSED_MANUAL },
            applicantIdsWithCompletedCadence
        );
        NurturingTrackService.CadenceWrapper cadenceWrapperManual = new NurturingTrackService.CadenceWrapper(
            Contact.getSObjectType(),
            null,
            DOMESTIC_OFFER_LAPSED_MANUAL
        );
        List<Contact> contactToUpdateListManual = (List<Contact>) NurturingTrackService.populateCalculatedCadenceSingle(
            filteredApplicantIdsWithCompletedCadence,
            applicantManual.values(),
            cadenceWrapperManual
        );
        contactsToUpdateMap.putAll(new Map<Id, Contact>(contactToUpdateListManual));
    }

    private static boolean setwithinOffSetDays(hed__Application__c app, Double offsetDays){
        return (app.Calculated_Intake_Date__c.addDays(-(Integer) offsetDays) <= System.today() &&
        app.Calculated_Intake_Date__c >= System.today());
    }

    private static boolean checkAppInternationalApplicationToOffer(hed__Application__c app){
        return (
        app.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID  &&
        ApplicationsDAO.INTL_ENTRY_APPLICATION_TO_OFFER_STATUSES_FOR_STUDYLINK.contains(app.Application_Status__c) &&
        NurturingTrackService.isDateWithinRange(
            app.Calculated_Intake_Date__c,
            CURRENT_INTAKE_PERIOD.get('START_DATE'),
            CURRENT_INTAKE_PERIOD.get('END_DATE')
        ) &&        
        app.Is_Agent_Assisted__c == false);
    }

    private static Map<Id, Contact> getEntryInternationalStrongInterestPreApplication(Map<Id, Contact> internationalEntryContactMap) {
        Map<String, Nurture_Track_Configuration__c> intlEntryStrongInterestPreAppConfigs = getIntlEntryStrongInterestPreAppConfigs();
        Map<Id, Set<String>> contactIdsWithCmpltdCadenceSet = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL,NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED},
            applicantIdsWithCompletedCadence
        );
        Set<String> completedCadencesCopy = new Set<String>();
        
        // Check Contact and Cadence Name if Manual is already Completed
        Set<Id> completedManualCadenceByContactId = NurturingTrackService.getFilteredApplicantWithCompletedCadence(
            internationalEntryContactMap.keySet(),
            new List<String>{ NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED },
            applicantIdsWithCompletedCadence
        ).keySet();
        
        Map<Id, List<String>> contactIdToCaseCategoriesMap = NurturingTrackService.getApplicantIdToRelatedCaseCategoriesMap(internationalEntryContactMap.keySet(), 3);
        Map<Id, Contact> contactsToUpdate = new Map<Id, Contact>();
        for(Contact internationalEntryContact : internationalEntryContactMap.values()) {
            
            boolean shouldContinueProcessing = contactIdsWithCmpltdCadenceSet.containsKey(internationalEntryContact.Id) && contactIdsWithCmpltdCadenceSet.get(internationalEntryContact.Id).size() >= 2;
            //get a copy of completed cadences related to the contact regardless of status
            completedCadencesCopy = applicantIdsWithAllCompletedCadence.containsKey(internationalEntryContact.Id)?new Set<String>(applicantIdsWithAllCompletedCadence.get(internationalEntryContact.Id)):new Set<String>();

            if (shouldContinueProcessing || 
                //make sure that there are no completed cadence against any succeeding cadence
                //this should return true if one of the succeeding cadence is already in compeltedCadencesCopy
                completedCadencesCopy.removeAll(NurtureTrackConfigurationsDAO.INTERNATIONAL_TRACK_SUCCEEDING_STRONG_INTEREST)) {
                continue;
            }
            
            Boolean isManual = !completedManualCadenceByContactId.contains(internationalEntryContact.Id);
            Decimal threshold = NurturingTrackService.selectThreshold(
                intlEntryStrongInterestPreAppConfigs, 
                NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL,
                isManual
            );
            List<String> l1Categories = NurturingTrackService.selectL1Categories(
                intlEntryStrongInterestPreAppConfigs, 
                NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL,
                isManual
            );
            List<String> relatedCaseCategories = contactIdToCaseCategoriesMap.get(internationalEntryContact.Id);
            if( // ... the contact...
                isContactWithNoActiveStudyLinkAppforXYears(internationalEntryContact, 3) &&  // ... has no active studylink app...
                internationalEntryContact.Lead_Score__c > threshold &&                       // ... has a lead score above threshold...
                NurturingTrackService.isRelatedCaseCategoriesContainsL1Categories(           // ... has a related case with a certain category...
                    l1Categories, 
                    relatedCaseCategories
                )
            ) {
                contactsToUpdate.put(
                    internationalEntryContact.Id, 
                    new Contact(
                        Id = internationalEntryContact.Id,
                        Calculated_Cadence__c = !isManual ?
                        NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL:
                        NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED
                    )
                );
            }
        }
        return contactsToUpdate;
    }

    private static Set<Id> getapplicationProgramUnderGrad(List<hed__Application__c> applications){
        Set<Id> applicationWithProgramLevelUnderGradIdSet = new Set<Id>();
        for(hed__Application__c app : applications){
            if(app.Offered_Program_Plan__c != null && app.Offered_Program_Plan__r.Program_Level__c == 'Undergraduate'){
                applicationWithProgramLevelUnderGradIdSet.add(app.Id);
            }
        }
        return applicationWithProgramLevelUnderGradIdSet;
    }

    private static Map<Id, Contact> getExitInternationalStrongInterestPreApplication(Map<Id, Contact> internationalExitContactMap) {
        List<String> cadenceNames = new List<String>{
            NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED, 
            NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL
        };
        Map<Id, Contact> contactsToUpdate = new Map<Id, Contact>();
        for(hed__Application__c application : applicationList) {
            Contact relatedContact = internationalExitContactMap.get(application.hed__Applicant__c);
            if(
                relatedContact != null &&
                cadenceNames.contains(relatedContact.Calculated_Cadence__c) && 
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID &&
                (!ApplicationsDAO.STUDYLINK_TERMINAL_STATUSES.contains(application.Application_Status__c) ||
                relatedContact.HasOptedOutOfEmail)
            ) {
                contactsToUpdate.put(
                    relatedContact.Id,
                    new Contact(
                        Id = relatedContact.Id,
                        Calculated_Cadence__c = ''
                    )
                );
            }
        }

        getContactHasOptedOutOfEmail(internationalExitContactMap, contactsToUpdate, cadenceNames);

        return contactsToUpdate;
    }

    private static void getContactHasOptedOutOfEmail(Map<Id, Contact> internationalExitContactMap, Map<Id, Contact> contactsToUpdate, List<String> cadenceNames) {
        for(Id contactId : internationalExitContactMap.keySet()) {
            Contact contactDetail = internationalExitContactMap.get(contactId);
            if (
                cadenceNames.contains(contactDetail.Calculated_Cadence__c) &&
                contactDetail.HasOptedOutOfEmail == true &&
                contactsToUpdate.get(contactDetail.Id) == null
            ) {
                contactsToUpdate.put(
                    contactDetail.Id,
                    new Contact(
                        Id = contactDetail.Id,
                        Calculated_Cadence__c = ''
                    )
                );
            }
        }
    }

    private static Boolean isContactWithNoActiveStudyLinkAppforXYears(Contact internationalEntryContact, Integer years) {
        Boolean hasActiveApplication = false;
        for(hed__Application__c application : applicationList) {
            Boolean isApplicantStudylinkApplication = 
                application.hed__Applicant__c == internationalEntryContact.Id && 
                application.RecordTypeId == ApplicationsDAO.STUDYLINK_RECTYPE_ID;
            Boolean isInitiallyCreatedWithinTimeRange = 
                application.hed__Initial_Creation_Date__c <= System.today() &&
                application.hed__Initial_Creation_Date__c >= System.today().addYears(-years);
            Boolean isActiveApplication = !ApplicationsDAO.STUDYLINK_TERMINAL_STATUSES.contains(application.Application_Status__c);
            if(
                isApplicantStudylinkApplication &&
                isInitiallyCreatedWithinTimeRange &&
                isActiveApplication
            ) {
                hasActiveApplication = true;
                break;
            }
        }
        return !hasActiveApplication;
    }

    private static Map<String, Nurture_Track_Configuration__c> getIntlEntryStrongInterestPreAppConfigs() {
        Map<String, Nurture_Track_Configuration__c> configsMap = new Map<String, Nurture_Track_Configuration__c>();
        for(Nurture_Track_Configuration__c config : NurtureTrackConfigurationsDAO.newInstance().getNurtureTrackByCadenceNames(
            new Set<String>{
                NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_AUTOMATED, 
                NurtureTrackConfigurationsDAO.INTERNATIONAL_STRONG_INTEREST_PRE_APPLICATION_MANUAL},
            'SYSTEM_MODE'
        )) {
            if(config.Criteria_Type__c == 'Entry') {
                configsMap.put(config.Cadence_Name__c, config);
            }
        }
        return configsMap;
    }
}